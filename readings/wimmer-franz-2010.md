# Linear Scan Register Allocation on SSA Form

_Christian Wimmer and Michael Franz, ACM International Symposium on Code Generation and Optimization, 2010, Pages 1-10._

## Commentary

This paper had a funny effect for me where the intuition of the approach led me to expect a slightly bigger performance payoff than the evaluation delivered. Admittedly, I'm focusing here on the fact that the authors' algorithm introduced no statistically significant speedup of the run time performance (bummer!); the compile time speedups are still somewhat encouraging though, particularly for a JIT context. In this vein, the elimination of the dataflow analysis for constructing lifetime intervals is the core exciting technique and contribution here. I was really struck by how the authors' leveraged the combination of certain properties of SSA form (namely, definitions dominate uses, uses in blocks outside of the definition's block imply a dominance relationship) and block ordering constraints to obviate the need for performing their analysis over a control flow graph. It almost seems like their lifetime interval construction algorithm (BuildIntervals, Figure 4) _shouldn't_ work, particularly when you can see analogs to the meet function (union of successors' `liveIn` sets) and transfer function (rest of the algorithm) that feel familiar to a dataflow analysis; I probably do need a bit more intuition build up here to _really_ understand why this is sufficient. Still, the 1.25-1.31x speedup from this change alone is a really nice result.

As a final comment, I also really enjoyed the latter portion of Section 3 discussing phi functions' lifetime intervals. The technique of treating phis as having _parallel copy_ semantics to lift any ordering constraint on moves inserted during SSA deconstruction is nice, and I like how the authors point out that this gives the register allocator a bit more freedom to make assignments. Additionally, the decision around how to demarcate phi functions' lifetime intervals (start at beginning of block) and their operands' lifetime intervals (end at end of predecessors)—and how this leads to phi functions with fewer lifetime holes—was quite elegant. In both cases, it seems like these decisions have material benefits for the register allocator (more freedom to make assignments, fewer state changes of intervals during allocation). Throughout this course, I feel like I've come to see phis as solving one major problem but occasionally introducing a few more in specific analysis cases. This paper's approach to dealing with phi functions flips that script for me a bit, demonstrating how they can actually help to simplify analysis information if we impose certain constraints on how we treat them.
